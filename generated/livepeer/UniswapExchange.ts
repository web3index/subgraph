// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class TokenPurchase extends ethereum.Event {
  get params(): TokenPurchase__Params {
    return new TokenPurchase__Params(this);
  }
}

export class TokenPurchase__Params {
  _event: TokenPurchase;

  constructor(event: TokenPurchase) {
    this._event = event;
  }

  get buyer(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get eth_sold(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get tokens_bought(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class EthPurchase extends ethereum.Event {
  get params(): EthPurchase__Params {
    return new EthPurchase__Params(this);
  }
}

export class EthPurchase__Params {
  _event: EthPurchase;

  constructor(event: EthPurchase) {
    this._event = event;
  }

  get buyer(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get tokens_sold(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get eth_bought(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class AddLiquidity extends ethereum.Event {
  get params(): AddLiquidity__Params {
    return new AddLiquidity__Params(this);
  }
}

export class AddLiquidity__Params {
  _event: AddLiquidity;

  constructor(event: AddLiquidity) {
    this._event = event;
  }

  get provider(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get eth_amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get token_amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class RemoveLiquidity extends ethereum.Event {
  get params(): RemoveLiquidity__Params {
    return new RemoveLiquidity__Params(this);
  }
}

export class RemoveLiquidity__Params {
  _event: RemoveLiquidity;

  constructor(event: RemoveLiquidity) {
    this._event = event;
  }

  get provider(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get eth_amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get token_amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Transfer extends ethereum.Event {
  get params(): Transfer__Params {
    return new Transfer__Params(this);
  }
}

export class Transfer__Params {
  _event: Transfer;

  constructor(event: Transfer) {
    this._event = event;
  }

  get _from(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _to(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get _value(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Approval extends ethereum.Event {
  get params(): Approval__Params {
    return new Approval__Params(this);
  }
}

export class Approval__Params {
  _event: Approval;

  constructor(event: Approval) {
    this._event = event;
  }

  get _owner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _spender(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get _value(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class UniswapExchange__removeLiquidityResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class UniswapExchange extends ethereum.SmartContract {
  static bind(address: Address): UniswapExchange {
    return new UniswapExchange("UniswapExchange", address);
  }

  removeLiquidity(
    amount: BigInt,
    min_eth: BigInt,
    min_tokens: BigInt,
    deadline: BigInt
  ): UniswapExchange__removeLiquidityResult {
    let result = super.call(
      "removeLiquidity",
      "removeLiquidity(uint256,uint256,uint256,uint256):(uint256,uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromUnsignedBigInt(min_eth),
        ethereum.Value.fromUnsignedBigInt(min_tokens),
        ethereum.Value.fromUnsignedBigInt(deadline)
      ]
    );

    return new UniswapExchange__removeLiquidityResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_removeLiquidity(
    amount: BigInt,
    min_eth: BigInt,
    min_tokens: BigInt,
    deadline: BigInt
  ): ethereum.CallResult<UniswapExchange__removeLiquidityResult> {
    let result = super.tryCall(
      "removeLiquidity",
      "removeLiquidity(uint256,uint256,uint256,uint256):(uint256,uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromUnsignedBigInt(min_eth),
        ethereum.Value.fromUnsignedBigInt(min_tokens),
        ethereum.Value.fromUnsignedBigInt(deadline)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new UniswapExchange__removeLiquidityResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  tokenToEthSwapInput(
    tokens_sold: BigInt,
    min_eth: BigInt,
    deadline: BigInt
  ): BigInt {
    let result = super.call(
      "tokenToEthSwapInput",
      "tokenToEthSwapInput(uint256,uint256,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(tokens_sold),
        ethereum.Value.fromUnsignedBigInt(min_eth),
        ethereum.Value.fromUnsignedBigInt(deadline)
      ]
    );

    return result[0].toBigInt();
  }

  try_tokenToEthSwapInput(
    tokens_sold: BigInt,
    min_eth: BigInt,
    deadline: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "tokenToEthSwapInput",
      "tokenToEthSwapInput(uint256,uint256,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(tokens_sold),
        ethereum.Value.fromUnsignedBigInt(min_eth),
        ethereum.Value.fromUnsignedBigInt(deadline)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  tokenToEthTransferInput(
    tokens_sold: BigInt,
    min_eth: BigInt,
    deadline: BigInt,
    recipient: Address
  ): BigInt {
    let result = super.call(
      "tokenToEthTransferInput",
      "tokenToEthTransferInput(uint256,uint256,uint256,address):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(tokens_sold),
        ethereum.Value.fromUnsignedBigInt(min_eth),
        ethereum.Value.fromUnsignedBigInt(deadline),
        ethereum.Value.fromAddress(recipient)
      ]
    );

    return result[0].toBigInt();
  }

  try_tokenToEthTransferInput(
    tokens_sold: BigInt,
    min_eth: BigInt,
    deadline: BigInt,
    recipient: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "tokenToEthTransferInput",
      "tokenToEthTransferInput(uint256,uint256,uint256,address):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(tokens_sold),
        ethereum.Value.fromUnsignedBigInt(min_eth),
        ethereum.Value.fromUnsignedBigInt(deadline),
        ethereum.Value.fromAddress(recipient)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  tokenToEthSwapOutput(
    eth_bought: BigInt,
    max_tokens: BigInt,
    deadline: BigInt
  ): BigInt {
    let result = super.call(
      "tokenToEthSwapOutput",
      "tokenToEthSwapOutput(uint256,uint256,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(eth_bought),
        ethereum.Value.fromUnsignedBigInt(max_tokens),
        ethereum.Value.fromUnsignedBigInt(deadline)
      ]
    );

    return result[0].toBigInt();
  }

  try_tokenToEthSwapOutput(
    eth_bought: BigInt,
    max_tokens: BigInt,
    deadline: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "tokenToEthSwapOutput",
      "tokenToEthSwapOutput(uint256,uint256,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(eth_bought),
        ethereum.Value.fromUnsignedBigInt(max_tokens),
        ethereum.Value.fromUnsignedBigInt(deadline)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  tokenToEthTransferOutput(
    eth_bought: BigInt,
    max_tokens: BigInt,
    deadline: BigInt,
    recipient: Address
  ): BigInt {
    let result = super.call(
      "tokenToEthTransferOutput",
      "tokenToEthTransferOutput(uint256,uint256,uint256,address):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(eth_bought),
        ethereum.Value.fromUnsignedBigInt(max_tokens),
        ethereum.Value.fromUnsignedBigInt(deadline),
        ethereum.Value.fromAddress(recipient)
      ]
    );

    return result[0].toBigInt();
  }

  try_tokenToEthTransferOutput(
    eth_bought: BigInt,
    max_tokens: BigInt,
    deadline: BigInt,
    recipient: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "tokenToEthTransferOutput",
      "tokenToEthTransferOutput(uint256,uint256,uint256,address):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(eth_bought),
        ethereum.Value.fromUnsignedBigInt(max_tokens),
        ethereum.Value.fromUnsignedBigInt(deadline),
        ethereum.Value.fromAddress(recipient)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  tokenToTokenSwapInput(
    tokens_sold: BigInt,
    min_tokens_bought: BigInt,
    min_eth_bought: BigInt,
    deadline: BigInt,
    token_addr: Address
  ): BigInt {
    let result = super.call(
      "tokenToTokenSwapInput",
      "tokenToTokenSwapInput(uint256,uint256,uint256,uint256,address):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(tokens_sold),
        ethereum.Value.fromUnsignedBigInt(min_tokens_bought),
        ethereum.Value.fromUnsignedBigInt(min_eth_bought),
        ethereum.Value.fromUnsignedBigInt(deadline),
        ethereum.Value.fromAddress(token_addr)
      ]
    );

    return result[0].toBigInt();
  }

  try_tokenToTokenSwapInput(
    tokens_sold: BigInt,
    min_tokens_bought: BigInt,
    min_eth_bought: BigInt,
    deadline: BigInt,
    token_addr: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "tokenToTokenSwapInput",
      "tokenToTokenSwapInput(uint256,uint256,uint256,uint256,address):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(tokens_sold),
        ethereum.Value.fromUnsignedBigInt(min_tokens_bought),
        ethereum.Value.fromUnsignedBigInt(min_eth_bought),
        ethereum.Value.fromUnsignedBigInt(deadline),
        ethereum.Value.fromAddress(token_addr)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  tokenToTokenTransferInput(
    tokens_sold: BigInt,
    min_tokens_bought: BigInt,
    min_eth_bought: BigInt,
    deadline: BigInt,
    recipient: Address,
    token_addr: Address
  ): BigInt {
    let result = super.call(
      "tokenToTokenTransferInput",
      "tokenToTokenTransferInput(uint256,uint256,uint256,uint256,address,address):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(tokens_sold),
        ethereum.Value.fromUnsignedBigInt(min_tokens_bought),
        ethereum.Value.fromUnsignedBigInt(min_eth_bought),
        ethereum.Value.fromUnsignedBigInt(deadline),
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromAddress(token_addr)
      ]
    );

    return result[0].toBigInt();
  }

  try_tokenToTokenTransferInput(
    tokens_sold: BigInt,
    min_tokens_bought: BigInt,
    min_eth_bought: BigInt,
    deadline: BigInt,
    recipient: Address,
    token_addr: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "tokenToTokenTransferInput",
      "tokenToTokenTransferInput(uint256,uint256,uint256,uint256,address,address):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(tokens_sold),
        ethereum.Value.fromUnsignedBigInt(min_tokens_bought),
        ethereum.Value.fromUnsignedBigInt(min_eth_bought),
        ethereum.Value.fromUnsignedBigInt(deadline),
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromAddress(token_addr)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  tokenToTokenSwapOutput(
    tokens_bought: BigInt,
    max_tokens_sold: BigInt,
    max_eth_sold: BigInt,
    deadline: BigInt,
    token_addr: Address
  ): BigInt {
    let result = super.call(
      "tokenToTokenSwapOutput",
      "tokenToTokenSwapOutput(uint256,uint256,uint256,uint256,address):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(tokens_bought),
        ethereum.Value.fromUnsignedBigInt(max_tokens_sold),
        ethereum.Value.fromUnsignedBigInt(max_eth_sold),
        ethereum.Value.fromUnsignedBigInt(deadline),
        ethereum.Value.fromAddress(token_addr)
      ]
    );

    return result[0].toBigInt();
  }

  try_tokenToTokenSwapOutput(
    tokens_bought: BigInt,
    max_tokens_sold: BigInt,
    max_eth_sold: BigInt,
    deadline: BigInt,
    token_addr: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "tokenToTokenSwapOutput",
      "tokenToTokenSwapOutput(uint256,uint256,uint256,uint256,address):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(tokens_bought),
        ethereum.Value.fromUnsignedBigInt(max_tokens_sold),
        ethereum.Value.fromUnsignedBigInt(max_eth_sold),
        ethereum.Value.fromUnsignedBigInt(deadline),
        ethereum.Value.fromAddress(token_addr)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  tokenToTokenTransferOutput(
    tokens_bought: BigInt,
    max_tokens_sold: BigInt,
    max_eth_sold: BigInt,
    deadline: BigInt,
    recipient: Address,
    token_addr: Address
  ): BigInt {
    let result = super.call(
      "tokenToTokenTransferOutput",
      "tokenToTokenTransferOutput(uint256,uint256,uint256,uint256,address,address):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(tokens_bought),
        ethereum.Value.fromUnsignedBigInt(max_tokens_sold),
        ethereum.Value.fromUnsignedBigInt(max_eth_sold),
        ethereum.Value.fromUnsignedBigInt(deadline),
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromAddress(token_addr)
      ]
    );

    return result[0].toBigInt();
  }

  try_tokenToTokenTransferOutput(
    tokens_bought: BigInt,
    max_tokens_sold: BigInt,
    max_eth_sold: BigInt,
    deadline: BigInt,
    recipient: Address,
    token_addr: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "tokenToTokenTransferOutput",
      "tokenToTokenTransferOutput(uint256,uint256,uint256,uint256,address,address):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(tokens_bought),
        ethereum.Value.fromUnsignedBigInt(max_tokens_sold),
        ethereum.Value.fromUnsignedBigInt(max_eth_sold),
        ethereum.Value.fromUnsignedBigInt(deadline),
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromAddress(token_addr)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  tokenToExchangeSwapInput(
    tokens_sold: BigInt,
    min_tokens_bought: BigInt,
    min_eth_bought: BigInt,
    deadline: BigInt,
    exchange_addr: Address
  ): BigInt {
    let result = super.call(
      "tokenToExchangeSwapInput",
      "tokenToExchangeSwapInput(uint256,uint256,uint256,uint256,address):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(tokens_sold),
        ethereum.Value.fromUnsignedBigInt(min_tokens_bought),
        ethereum.Value.fromUnsignedBigInt(min_eth_bought),
        ethereum.Value.fromUnsignedBigInt(deadline),
        ethereum.Value.fromAddress(exchange_addr)
      ]
    );

    return result[0].toBigInt();
  }

  try_tokenToExchangeSwapInput(
    tokens_sold: BigInt,
    min_tokens_bought: BigInt,
    min_eth_bought: BigInt,
    deadline: BigInt,
    exchange_addr: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "tokenToExchangeSwapInput",
      "tokenToExchangeSwapInput(uint256,uint256,uint256,uint256,address):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(tokens_sold),
        ethereum.Value.fromUnsignedBigInt(min_tokens_bought),
        ethereum.Value.fromUnsignedBigInt(min_eth_bought),
        ethereum.Value.fromUnsignedBigInt(deadline),
        ethereum.Value.fromAddress(exchange_addr)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  tokenToExchangeTransferInput(
    tokens_sold: BigInt,
    min_tokens_bought: BigInt,
    min_eth_bought: BigInt,
    deadline: BigInt,
    recipient: Address,
    exchange_addr: Address
  ): BigInt {
    let result = super.call(
      "tokenToExchangeTransferInput",
      "tokenToExchangeTransferInput(uint256,uint256,uint256,uint256,address,address):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(tokens_sold),
        ethereum.Value.fromUnsignedBigInt(min_tokens_bought),
        ethereum.Value.fromUnsignedBigInt(min_eth_bought),
        ethereum.Value.fromUnsignedBigInt(deadline),
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromAddress(exchange_addr)
      ]
    );

    return result[0].toBigInt();
  }

  try_tokenToExchangeTransferInput(
    tokens_sold: BigInt,
    min_tokens_bought: BigInt,
    min_eth_bought: BigInt,
    deadline: BigInt,
    recipient: Address,
    exchange_addr: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "tokenToExchangeTransferInput",
      "tokenToExchangeTransferInput(uint256,uint256,uint256,uint256,address,address):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(tokens_sold),
        ethereum.Value.fromUnsignedBigInt(min_tokens_bought),
        ethereum.Value.fromUnsignedBigInt(min_eth_bought),
        ethereum.Value.fromUnsignedBigInt(deadline),
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromAddress(exchange_addr)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  tokenToExchangeSwapOutput(
    tokens_bought: BigInt,
    max_tokens_sold: BigInt,
    max_eth_sold: BigInt,
    deadline: BigInt,
    exchange_addr: Address
  ): BigInt {
    let result = super.call(
      "tokenToExchangeSwapOutput",
      "tokenToExchangeSwapOutput(uint256,uint256,uint256,uint256,address):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(tokens_bought),
        ethereum.Value.fromUnsignedBigInt(max_tokens_sold),
        ethereum.Value.fromUnsignedBigInt(max_eth_sold),
        ethereum.Value.fromUnsignedBigInt(deadline),
        ethereum.Value.fromAddress(exchange_addr)
      ]
    );

    return result[0].toBigInt();
  }

  try_tokenToExchangeSwapOutput(
    tokens_bought: BigInt,
    max_tokens_sold: BigInt,
    max_eth_sold: BigInt,
    deadline: BigInt,
    exchange_addr: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "tokenToExchangeSwapOutput",
      "tokenToExchangeSwapOutput(uint256,uint256,uint256,uint256,address):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(tokens_bought),
        ethereum.Value.fromUnsignedBigInt(max_tokens_sold),
        ethereum.Value.fromUnsignedBigInt(max_eth_sold),
        ethereum.Value.fromUnsignedBigInt(deadline),
        ethereum.Value.fromAddress(exchange_addr)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  tokenToExchangeTransferOutput(
    tokens_bought: BigInt,
    max_tokens_sold: BigInt,
    max_eth_sold: BigInt,
    deadline: BigInt,
    recipient: Address,
    exchange_addr: Address
  ): BigInt {
    let result = super.call(
      "tokenToExchangeTransferOutput",
      "tokenToExchangeTransferOutput(uint256,uint256,uint256,uint256,address,address):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(tokens_bought),
        ethereum.Value.fromUnsignedBigInt(max_tokens_sold),
        ethereum.Value.fromUnsignedBigInt(max_eth_sold),
        ethereum.Value.fromUnsignedBigInt(deadline),
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromAddress(exchange_addr)
      ]
    );

    return result[0].toBigInt();
  }

  try_tokenToExchangeTransferOutput(
    tokens_bought: BigInt,
    max_tokens_sold: BigInt,
    max_eth_sold: BigInt,
    deadline: BigInt,
    recipient: Address,
    exchange_addr: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "tokenToExchangeTransferOutput",
      "tokenToExchangeTransferOutput(uint256,uint256,uint256,uint256,address,address):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(tokens_bought),
        ethereum.Value.fromUnsignedBigInt(max_tokens_sold),
        ethereum.Value.fromUnsignedBigInt(max_eth_sold),
        ethereum.Value.fromUnsignedBigInt(deadline),
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromAddress(exchange_addr)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getEthToTokenInputPrice(eth_sold: BigInt): BigInt {
    let result = super.call(
      "getEthToTokenInputPrice",
      "getEthToTokenInputPrice(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(eth_sold)]
    );

    return result[0].toBigInt();
  }

  try_getEthToTokenInputPrice(eth_sold: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getEthToTokenInputPrice",
      "getEthToTokenInputPrice(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(eth_sold)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getEthToTokenOutputPrice(tokens_bought: BigInt): BigInt {
    let result = super.call(
      "getEthToTokenOutputPrice",
      "getEthToTokenOutputPrice(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(tokens_bought)]
    );

    return result[0].toBigInt();
  }

  try_getEthToTokenOutputPrice(
    tokens_bought: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getEthToTokenOutputPrice",
      "getEthToTokenOutputPrice(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(tokens_bought)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getTokenToEthInputPrice(tokens_sold: BigInt): BigInt {
    let result = super.call(
      "getTokenToEthInputPrice",
      "getTokenToEthInputPrice(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(tokens_sold)]
    );

    return result[0].toBigInt();
  }

  try_getTokenToEthInputPrice(
    tokens_sold: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getTokenToEthInputPrice",
      "getTokenToEthInputPrice(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(tokens_sold)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getTokenToEthOutputPrice(eth_bought: BigInt): BigInt {
    let result = super.call(
      "getTokenToEthOutputPrice",
      "getTokenToEthOutputPrice(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(eth_bought)]
    );

    return result[0].toBigInt();
  }

  try_getTokenToEthOutputPrice(
    eth_bought: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getTokenToEthOutputPrice",
      "getTokenToEthOutputPrice(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(eth_bought)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  tokenAddress(): Address {
    let result = super.call("tokenAddress", "tokenAddress():(address)", []);

    return result[0].toAddress();
  }

  try_tokenAddress(): ethereum.CallResult<Address> {
    let result = super.tryCall("tokenAddress", "tokenAddress():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  factoryAddress(): Address {
    let result = super.call("factoryAddress", "factoryAddress():(address)", []);

    return result[0].toAddress();
  }

  try_factoryAddress(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "factoryAddress",
      "factoryAddress():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  balanceOf(_owner: Address): BigInt {
    let result = super.call("balanceOf", "balanceOf(address):(uint256)", [
      ethereum.Value.fromAddress(_owner)
    ]);

    return result[0].toBigInt();
  }

  try_balanceOf(_owner: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("balanceOf", "balanceOf(address):(uint256)", [
      ethereum.Value.fromAddress(_owner)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  transfer(_to: Address, _value: BigInt): boolean {
    let result = super.call("transfer", "transfer(address,uint256):(bool)", [
      ethereum.Value.fromAddress(_to),
      ethereum.Value.fromUnsignedBigInt(_value)
    ]);

    return result[0].toBoolean();
  }

  try_transfer(_to: Address, _value: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall("transfer", "transfer(address,uint256):(bool)", [
      ethereum.Value.fromAddress(_to),
      ethereum.Value.fromUnsignedBigInt(_value)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  transferFrom(_from: Address, _to: Address, _value: BigInt): boolean {
    let result = super.call(
      "transferFrom",
      "transferFrom(address,address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(_from),
        ethereum.Value.fromAddress(_to),
        ethereum.Value.fromUnsignedBigInt(_value)
      ]
    );

    return result[0].toBoolean();
  }

  try_transferFrom(
    _from: Address,
    _to: Address,
    _value: BigInt
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "transferFrom",
      "transferFrom(address,address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(_from),
        ethereum.Value.fromAddress(_to),
        ethereum.Value.fromUnsignedBigInt(_value)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  approve(_spender: Address, _value: BigInt): boolean {
    let result = super.call("approve", "approve(address,uint256):(bool)", [
      ethereum.Value.fromAddress(_spender),
      ethereum.Value.fromUnsignedBigInt(_value)
    ]);

    return result[0].toBoolean();
  }

  try_approve(_spender: Address, _value: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall("approve", "approve(address,uint256):(bool)", [
      ethereum.Value.fromAddress(_spender),
      ethereum.Value.fromUnsignedBigInt(_value)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  allowance(_owner: Address, _spender: Address): BigInt {
    let result = super.call(
      "allowance",
      "allowance(address,address):(uint256)",
      [ethereum.Value.fromAddress(_owner), ethereum.Value.fromAddress(_spender)]
    );

    return result[0].toBigInt();
  }

  try_allowance(
    _owner: Address,
    _spender: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "allowance",
      "allowance(address,address):(uint256)",
      [ethereum.Value.fromAddress(_owner), ethereum.Value.fromAddress(_spender)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  name(): Bytes {
    let result = super.call("name", "name():(bytes32)", []);

    return result[0].toBytes();
  }

  try_name(): ethereum.CallResult<Bytes> {
    let result = super.tryCall("name", "name():(bytes32)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  symbol(): Bytes {
    let result = super.call("symbol", "symbol():(bytes32)", []);

    return result[0].toBytes();
  }

  try_symbol(): ethereum.CallResult<Bytes> {
    let result = super.tryCall("symbol", "symbol():(bytes32)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  decimals(): BigInt {
    let result = super.call("decimals", "decimals():(uint256)", []);

    return result[0].toBigInt();
  }

  try_decimals(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("decimals", "decimals():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  totalSupply(): BigInt {
    let result = super.call("totalSupply", "totalSupply():(uint256)", []);

    return result[0].toBigInt();
  }

  try_totalSupply(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("totalSupply", "totalSupply():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }
}

export class SetupCall extends ethereum.Call {
  get inputs(): SetupCall__Inputs {
    return new SetupCall__Inputs(this);
  }

  get outputs(): SetupCall__Outputs {
    return new SetupCall__Outputs(this);
  }
}

export class SetupCall__Inputs {
  _call: SetupCall;

  constructor(call: SetupCall) {
    this._call = call;
  }

  get token_addr(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetupCall__Outputs {
  _call: SetupCall;

  constructor(call: SetupCall) {
    this._call = call;
  }
}

export class AddLiquidityCall extends ethereum.Call {
  get inputs(): AddLiquidityCall__Inputs {
    return new AddLiquidityCall__Inputs(this);
  }

  get outputs(): AddLiquidityCall__Outputs {
    return new AddLiquidityCall__Outputs(this);
  }
}

export class AddLiquidityCall__Inputs {
  _call: AddLiquidityCall;

  constructor(call: AddLiquidityCall) {
    this._call = call;
  }

  get min_liquidity(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get max_tokens(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get deadline(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class AddLiquidityCall__Outputs {
  _call: AddLiquidityCall;

  constructor(call: AddLiquidityCall) {
    this._call = call;
  }

  get out(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class RemoveLiquidityCall extends ethereum.Call {
  get inputs(): RemoveLiquidityCall__Inputs {
    return new RemoveLiquidityCall__Inputs(this);
  }

  get outputs(): RemoveLiquidityCall__Outputs {
    return new RemoveLiquidityCall__Outputs(this);
  }
}

export class RemoveLiquidityCall__Inputs {
  _call: RemoveLiquidityCall;

  constructor(call: RemoveLiquidityCall) {
    this._call = call;
  }

  get amount(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get min_eth(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get min_tokens(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get deadline(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }
}

export class RemoveLiquidityCall__Outputs {
  _call: RemoveLiquidityCall;

  constructor(call: RemoveLiquidityCall) {
    this._call = call;
  }

  get out(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }

  get out1(): BigInt {
    return this._call.outputValues[1].value.toBigInt();
  }
}

export class __default__Call extends ethereum.Call {
  get inputs(): __default__Call__Inputs {
    return new __default__Call__Inputs(this);
  }

  get outputs(): __default__Call__Outputs {
    return new __default__Call__Outputs(this);
  }
}

export class __default__Call__Inputs {
  _call: __default__Call;

  constructor(call: __default__Call) {
    this._call = call;
  }
}

export class __default__Call__Outputs {
  _call: __default__Call;

  constructor(call: __default__Call) {
    this._call = call;
  }
}

export class EthToTokenSwapInputCall extends ethereum.Call {
  get inputs(): EthToTokenSwapInputCall__Inputs {
    return new EthToTokenSwapInputCall__Inputs(this);
  }

  get outputs(): EthToTokenSwapInputCall__Outputs {
    return new EthToTokenSwapInputCall__Outputs(this);
  }
}

export class EthToTokenSwapInputCall__Inputs {
  _call: EthToTokenSwapInputCall;

  constructor(call: EthToTokenSwapInputCall) {
    this._call = call;
  }

  get min_tokens(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get deadline(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class EthToTokenSwapInputCall__Outputs {
  _call: EthToTokenSwapInputCall;

  constructor(call: EthToTokenSwapInputCall) {
    this._call = call;
  }

  get out(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class EthToTokenTransferInputCall extends ethereum.Call {
  get inputs(): EthToTokenTransferInputCall__Inputs {
    return new EthToTokenTransferInputCall__Inputs(this);
  }

  get outputs(): EthToTokenTransferInputCall__Outputs {
    return new EthToTokenTransferInputCall__Outputs(this);
  }
}

export class EthToTokenTransferInputCall__Inputs {
  _call: EthToTokenTransferInputCall;

  constructor(call: EthToTokenTransferInputCall) {
    this._call = call;
  }

  get min_tokens(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get deadline(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get recipient(): Address {
    return this._call.inputValues[2].value.toAddress();
  }
}

export class EthToTokenTransferInputCall__Outputs {
  _call: EthToTokenTransferInputCall;

  constructor(call: EthToTokenTransferInputCall) {
    this._call = call;
  }

  get out(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class EthToTokenSwapOutputCall extends ethereum.Call {
  get inputs(): EthToTokenSwapOutputCall__Inputs {
    return new EthToTokenSwapOutputCall__Inputs(this);
  }

  get outputs(): EthToTokenSwapOutputCall__Outputs {
    return new EthToTokenSwapOutputCall__Outputs(this);
  }
}

export class EthToTokenSwapOutputCall__Inputs {
  _call: EthToTokenSwapOutputCall;

  constructor(call: EthToTokenSwapOutputCall) {
    this._call = call;
  }

  get tokens_bought(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get deadline(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class EthToTokenSwapOutputCall__Outputs {
  _call: EthToTokenSwapOutputCall;

  constructor(call: EthToTokenSwapOutputCall) {
    this._call = call;
  }

  get out(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class EthToTokenTransferOutputCall extends ethereum.Call {
  get inputs(): EthToTokenTransferOutputCall__Inputs {
    return new EthToTokenTransferOutputCall__Inputs(this);
  }

  get outputs(): EthToTokenTransferOutputCall__Outputs {
    return new EthToTokenTransferOutputCall__Outputs(this);
  }
}

export class EthToTokenTransferOutputCall__Inputs {
  _call: EthToTokenTransferOutputCall;

  constructor(call: EthToTokenTransferOutputCall) {
    this._call = call;
  }

  get tokens_bought(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get deadline(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get recipient(): Address {
    return this._call.inputValues[2].value.toAddress();
  }
}

export class EthToTokenTransferOutputCall__Outputs {
  _call: EthToTokenTransferOutputCall;

  constructor(call: EthToTokenTransferOutputCall) {
    this._call = call;
  }

  get out(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class TokenToEthSwapInputCall extends ethereum.Call {
  get inputs(): TokenToEthSwapInputCall__Inputs {
    return new TokenToEthSwapInputCall__Inputs(this);
  }

  get outputs(): TokenToEthSwapInputCall__Outputs {
    return new TokenToEthSwapInputCall__Outputs(this);
  }
}

export class TokenToEthSwapInputCall__Inputs {
  _call: TokenToEthSwapInputCall;

  constructor(call: TokenToEthSwapInputCall) {
    this._call = call;
  }

  get tokens_sold(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get min_eth(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get deadline(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class TokenToEthSwapInputCall__Outputs {
  _call: TokenToEthSwapInputCall;

  constructor(call: TokenToEthSwapInputCall) {
    this._call = call;
  }

  get out(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class TokenToEthTransferInputCall extends ethereum.Call {
  get inputs(): TokenToEthTransferInputCall__Inputs {
    return new TokenToEthTransferInputCall__Inputs(this);
  }

  get outputs(): TokenToEthTransferInputCall__Outputs {
    return new TokenToEthTransferInputCall__Outputs(this);
  }
}

export class TokenToEthTransferInputCall__Inputs {
  _call: TokenToEthTransferInputCall;

  constructor(call: TokenToEthTransferInputCall) {
    this._call = call;
  }

  get tokens_sold(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get min_eth(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get deadline(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get recipient(): Address {
    return this._call.inputValues[3].value.toAddress();
  }
}

export class TokenToEthTransferInputCall__Outputs {
  _call: TokenToEthTransferInputCall;

  constructor(call: TokenToEthTransferInputCall) {
    this._call = call;
  }

  get out(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class TokenToEthSwapOutputCall extends ethereum.Call {
  get inputs(): TokenToEthSwapOutputCall__Inputs {
    return new TokenToEthSwapOutputCall__Inputs(this);
  }

  get outputs(): TokenToEthSwapOutputCall__Outputs {
    return new TokenToEthSwapOutputCall__Outputs(this);
  }
}

export class TokenToEthSwapOutputCall__Inputs {
  _call: TokenToEthSwapOutputCall;

  constructor(call: TokenToEthSwapOutputCall) {
    this._call = call;
  }

  get eth_bought(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get max_tokens(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get deadline(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class TokenToEthSwapOutputCall__Outputs {
  _call: TokenToEthSwapOutputCall;

  constructor(call: TokenToEthSwapOutputCall) {
    this._call = call;
  }

  get out(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class TokenToEthTransferOutputCall extends ethereum.Call {
  get inputs(): TokenToEthTransferOutputCall__Inputs {
    return new TokenToEthTransferOutputCall__Inputs(this);
  }

  get outputs(): TokenToEthTransferOutputCall__Outputs {
    return new TokenToEthTransferOutputCall__Outputs(this);
  }
}

export class TokenToEthTransferOutputCall__Inputs {
  _call: TokenToEthTransferOutputCall;

  constructor(call: TokenToEthTransferOutputCall) {
    this._call = call;
  }

  get eth_bought(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get max_tokens(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get deadline(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get recipient(): Address {
    return this._call.inputValues[3].value.toAddress();
  }
}

export class TokenToEthTransferOutputCall__Outputs {
  _call: TokenToEthTransferOutputCall;

  constructor(call: TokenToEthTransferOutputCall) {
    this._call = call;
  }

  get out(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class TokenToTokenSwapInputCall extends ethereum.Call {
  get inputs(): TokenToTokenSwapInputCall__Inputs {
    return new TokenToTokenSwapInputCall__Inputs(this);
  }

  get outputs(): TokenToTokenSwapInputCall__Outputs {
    return new TokenToTokenSwapInputCall__Outputs(this);
  }
}

export class TokenToTokenSwapInputCall__Inputs {
  _call: TokenToTokenSwapInputCall;

  constructor(call: TokenToTokenSwapInputCall) {
    this._call = call;
  }

  get tokens_sold(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get min_tokens_bought(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get min_eth_bought(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get deadline(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get token_addr(): Address {
    return this._call.inputValues[4].value.toAddress();
  }
}

export class TokenToTokenSwapInputCall__Outputs {
  _call: TokenToTokenSwapInputCall;

  constructor(call: TokenToTokenSwapInputCall) {
    this._call = call;
  }

  get out(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class TokenToTokenTransferInputCall extends ethereum.Call {
  get inputs(): TokenToTokenTransferInputCall__Inputs {
    return new TokenToTokenTransferInputCall__Inputs(this);
  }

  get outputs(): TokenToTokenTransferInputCall__Outputs {
    return new TokenToTokenTransferInputCall__Outputs(this);
  }
}

export class TokenToTokenTransferInputCall__Inputs {
  _call: TokenToTokenTransferInputCall;

  constructor(call: TokenToTokenTransferInputCall) {
    this._call = call;
  }

  get tokens_sold(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get min_tokens_bought(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get min_eth_bought(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get deadline(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get recipient(): Address {
    return this._call.inputValues[4].value.toAddress();
  }

  get token_addr(): Address {
    return this._call.inputValues[5].value.toAddress();
  }
}

export class TokenToTokenTransferInputCall__Outputs {
  _call: TokenToTokenTransferInputCall;

  constructor(call: TokenToTokenTransferInputCall) {
    this._call = call;
  }

  get out(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class TokenToTokenSwapOutputCall extends ethereum.Call {
  get inputs(): TokenToTokenSwapOutputCall__Inputs {
    return new TokenToTokenSwapOutputCall__Inputs(this);
  }

  get outputs(): TokenToTokenSwapOutputCall__Outputs {
    return new TokenToTokenSwapOutputCall__Outputs(this);
  }
}

export class TokenToTokenSwapOutputCall__Inputs {
  _call: TokenToTokenSwapOutputCall;

  constructor(call: TokenToTokenSwapOutputCall) {
    this._call = call;
  }

  get tokens_bought(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get max_tokens_sold(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get max_eth_sold(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get deadline(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get token_addr(): Address {
    return this._call.inputValues[4].value.toAddress();
  }
}

export class TokenToTokenSwapOutputCall__Outputs {
  _call: TokenToTokenSwapOutputCall;

  constructor(call: TokenToTokenSwapOutputCall) {
    this._call = call;
  }

  get out(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class TokenToTokenTransferOutputCall extends ethereum.Call {
  get inputs(): TokenToTokenTransferOutputCall__Inputs {
    return new TokenToTokenTransferOutputCall__Inputs(this);
  }

  get outputs(): TokenToTokenTransferOutputCall__Outputs {
    return new TokenToTokenTransferOutputCall__Outputs(this);
  }
}

export class TokenToTokenTransferOutputCall__Inputs {
  _call: TokenToTokenTransferOutputCall;

  constructor(call: TokenToTokenTransferOutputCall) {
    this._call = call;
  }

  get tokens_bought(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get max_tokens_sold(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get max_eth_sold(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get deadline(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get recipient(): Address {
    return this._call.inputValues[4].value.toAddress();
  }

  get token_addr(): Address {
    return this._call.inputValues[5].value.toAddress();
  }
}

export class TokenToTokenTransferOutputCall__Outputs {
  _call: TokenToTokenTransferOutputCall;

  constructor(call: TokenToTokenTransferOutputCall) {
    this._call = call;
  }

  get out(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class TokenToExchangeSwapInputCall extends ethereum.Call {
  get inputs(): TokenToExchangeSwapInputCall__Inputs {
    return new TokenToExchangeSwapInputCall__Inputs(this);
  }

  get outputs(): TokenToExchangeSwapInputCall__Outputs {
    return new TokenToExchangeSwapInputCall__Outputs(this);
  }
}

export class TokenToExchangeSwapInputCall__Inputs {
  _call: TokenToExchangeSwapInputCall;

  constructor(call: TokenToExchangeSwapInputCall) {
    this._call = call;
  }

  get tokens_sold(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get min_tokens_bought(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get min_eth_bought(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get deadline(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get exchange_addr(): Address {
    return this._call.inputValues[4].value.toAddress();
  }
}

export class TokenToExchangeSwapInputCall__Outputs {
  _call: TokenToExchangeSwapInputCall;

  constructor(call: TokenToExchangeSwapInputCall) {
    this._call = call;
  }

  get out(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class TokenToExchangeTransferInputCall extends ethereum.Call {
  get inputs(): TokenToExchangeTransferInputCall__Inputs {
    return new TokenToExchangeTransferInputCall__Inputs(this);
  }

  get outputs(): TokenToExchangeTransferInputCall__Outputs {
    return new TokenToExchangeTransferInputCall__Outputs(this);
  }
}

export class TokenToExchangeTransferInputCall__Inputs {
  _call: TokenToExchangeTransferInputCall;

  constructor(call: TokenToExchangeTransferInputCall) {
    this._call = call;
  }

  get tokens_sold(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get min_tokens_bought(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get min_eth_bought(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get deadline(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get recipient(): Address {
    return this._call.inputValues[4].value.toAddress();
  }

  get exchange_addr(): Address {
    return this._call.inputValues[5].value.toAddress();
  }
}

export class TokenToExchangeTransferInputCall__Outputs {
  _call: TokenToExchangeTransferInputCall;

  constructor(call: TokenToExchangeTransferInputCall) {
    this._call = call;
  }

  get out(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class TokenToExchangeSwapOutputCall extends ethereum.Call {
  get inputs(): TokenToExchangeSwapOutputCall__Inputs {
    return new TokenToExchangeSwapOutputCall__Inputs(this);
  }

  get outputs(): TokenToExchangeSwapOutputCall__Outputs {
    return new TokenToExchangeSwapOutputCall__Outputs(this);
  }
}

export class TokenToExchangeSwapOutputCall__Inputs {
  _call: TokenToExchangeSwapOutputCall;

  constructor(call: TokenToExchangeSwapOutputCall) {
    this._call = call;
  }

  get tokens_bought(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get max_tokens_sold(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get max_eth_sold(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get deadline(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get exchange_addr(): Address {
    return this._call.inputValues[4].value.toAddress();
  }
}

export class TokenToExchangeSwapOutputCall__Outputs {
  _call: TokenToExchangeSwapOutputCall;

  constructor(call: TokenToExchangeSwapOutputCall) {
    this._call = call;
  }

  get out(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class TokenToExchangeTransferOutputCall extends ethereum.Call {
  get inputs(): TokenToExchangeTransferOutputCall__Inputs {
    return new TokenToExchangeTransferOutputCall__Inputs(this);
  }

  get outputs(): TokenToExchangeTransferOutputCall__Outputs {
    return new TokenToExchangeTransferOutputCall__Outputs(this);
  }
}

export class TokenToExchangeTransferOutputCall__Inputs {
  _call: TokenToExchangeTransferOutputCall;

  constructor(call: TokenToExchangeTransferOutputCall) {
    this._call = call;
  }

  get tokens_bought(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get max_tokens_sold(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get max_eth_sold(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get deadline(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get recipient(): Address {
    return this._call.inputValues[4].value.toAddress();
  }

  get exchange_addr(): Address {
    return this._call.inputValues[5].value.toAddress();
  }
}

export class TokenToExchangeTransferOutputCall__Outputs {
  _call: TokenToExchangeTransferOutputCall;

  constructor(call: TokenToExchangeTransferOutputCall) {
    this._call = call;
  }

  get out(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class TransferCall extends ethereum.Call {
  get inputs(): TransferCall__Inputs {
    return new TransferCall__Inputs(this);
  }

  get outputs(): TransferCall__Outputs {
    return new TransferCall__Outputs(this);
  }
}

export class TransferCall__Inputs {
  _call: TransferCall;

  constructor(call: TransferCall) {
    this._call = call;
  }

  get _to(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _value(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class TransferCall__Outputs {
  _call: TransferCall;

  constructor(call: TransferCall) {
    this._call = call;
  }

  get out(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class TransferFromCall extends ethereum.Call {
  get inputs(): TransferFromCall__Inputs {
    return new TransferFromCall__Inputs(this);
  }

  get outputs(): TransferFromCall__Outputs {
    return new TransferFromCall__Outputs(this);
  }
}

export class TransferFromCall__Inputs {
  _call: TransferFromCall;

  constructor(call: TransferFromCall) {
    this._call = call;
  }

  get _from(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _to(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _value(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class TransferFromCall__Outputs {
  _call: TransferFromCall;

  constructor(call: TransferFromCall) {
    this._call = call;
  }

  get out(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class ApproveCall extends ethereum.Call {
  get inputs(): ApproveCall__Inputs {
    return new ApproveCall__Inputs(this);
  }

  get outputs(): ApproveCall__Outputs {
    return new ApproveCall__Outputs(this);
  }
}

export class ApproveCall__Inputs {
  _call: ApproveCall;

  constructor(call: ApproveCall) {
    this._call = call;
  }

  get _spender(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _value(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class ApproveCall__Outputs {
  _call: ApproveCall;

  constructor(call: ApproveCall) {
    this._call = call;
  }

  get out(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}
